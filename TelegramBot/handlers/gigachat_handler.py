import logging
import aiohttp
from typing import Dict, Any, Callable, Awaitable
from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from logic.query_analyze import QueryAnalyzer
from logic.dialogue_manager import DialogueManager
from logic.api_handlers import (
    handle_get_description, handle_get_picture, handle_draw_locate_map,
    handle_nearest, handle_objects_in_polygon, handle_geo_request, handle_comparison
)
from utils.bot_utils import send_long_message
from utils.context_manager import RedisContextManager
from config import API_URLS

logger = logging.getLogger(__name__)

# –¢–∏–ø–∏–∑–∞—Ü–∏—è –¥–ª—è –Ω–∞—à–∏—Ö —Å–ª–æ–≤–∞—Ä–µ–π-–¥–∏—Å–ø–µ—Ç—á–µ—Ä–æ–≤, —á—Ç–æ–±—ã –∫–æ–¥ –±—ã–ª –ø–æ–Ω—è—Ç–Ω–µ–µ
ActionHandler = Callable[[Dict[str, Any], str, str], Awaitable[list]]
CallbackHandler = Callable[[types.CallbackQuery], Awaitable[None]]

class GigaChatHandler:
    def __init__(self, qa: QueryAnalyzer, dialogue_manager: DialogueManager, session: aiohttp.ClientSession):
        self.qa = qa
        self.dialogue_manager = dialogue_manager
        self.session = session

        # --- –î–ò–°–ü–ï–¢–ß–ï–† –î–õ–Ø –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô ---
        # –ö–ª—é—á: (action, entity_type). –ó–Ω–∞—á–µ–Ω–∏–µ: —Ñ—É–Ω–∫—Ü–∏—è-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑ api_handlers.
        self.action_handlers: Dict[tuple[str, str], ActionHandler] = {
            ("describe", "Biological"): handle_get_description,
            ("describe", "Infrastructure"): handle_geo_request,
            ("describe", "GeoPlace"): handle_geo_request,
            ("show_image", "Biological"): handle_get_picture,
            ("show_map", "Biological"): handle_draw_locate_map,
            ("find_nearby", "ANY"): handle_nearest, # ANY - –¥–ª—è —Å–ª—É—á–∞–µ–≤, –≥–¥–µ —Ç–∏–ø –Ω–µ –≤–∞–∂–µ–Ω
            ("list_items", "Biological"): handle_objects_in_polygon,
            ("list_items", "Infrastructure"): handle_geo_request,
        }

        # --- –î–ò–°–ü–ï–¢–ß–ï–† –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò –ö–ù–û–ü–û–ö ---
        # –ö–ª—é—á: –ø—Ä–µ—Ñ–∏–∫—Å callback_data. –ó–Ω–∞—á–µ–Ω–∏–µ: –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –º–µ—Ç–æ–¥ —ç—Ç–æ–≥–æ –∫–ª–∞—Å—Å–∞.
        self.callback_handlers: Dict[str, CallbackHandler] = {
            "clarify_object": self._handle_clarify_object,
            "clarify_more": self._handle_pagination,
            "explore": self._handle_exploration,
            "fallback": self._handle_fallback,
        }

    async def process_message(self, message: types.Message):
        """–ì–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç, –æ–±–æ–≥–∞—â–∞–µ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑—É–µ—Ç."""
        user_id, query = str(message.chat.id), message.text
        
        try:
            await message.bot.send_chat_action(chat_id=user_id, action=types.ChatActions.TYPING)
            
            analysis = await self.qa.analyze_query(query)
            if not analysis:
                await self._reply_with_error(message, f"QueryAnalyzer –Ω–µ –≤–µ—Ä–Ω—É–ª –∞–Ω–∞–ª–∏–∑ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞: '{query}'")
                return

            final_analysis = await self.dialogue_manager.enrich_request(user_id, analysis)
            action = final_analysis.get("action")

            if not action or action == "unknown":
                await self._reply_with_error(message, f"–ò—Ç–æ–≥–æ–≤—ã–π action='unknown'. –ê–Ω–∞–ª–∏–∑: {final_analysis}", reply_text="–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É—Ç–æ—á–Ω–∏—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å.")
                return

            logger.info(f"[{user_id}] –†–æ—É—Ç–∏–Ω–≥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞: {final_analysis}")
            
            primary_entity_type = final_analysis.get("primary_entity", {}).get("type", "ANY")
            handler = self.action_handlers.get((action, primary_entity_type))
            
            # [–ò–ó–ú–ï–ù–ï–ù–ò–ï] - –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É count_items, –ø—Ä–∏–≤—è–∑—ã–≤–∞—è –µ–µ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É —Ö—ç–Ω–¥–ª–µ—Ä—É
            if not handler:
                if action == "count_items" and primary_entity_type == "Infrastructure":
                    handler = handle_geo_request
                else:
                    handler = self.action_handlers.get((action, "ANY"))

            if not handler:
                await self._reply_with_error(message, f"–î–ª—è –∞–Ω–∞–ª–∏–∑–∞ {final_analysis} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞.", reply_text="–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –ø–æ–∫–∞ –Ω–µ —É–º–µ—é –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–∞–∫–∏–µ –∑–∞–ø—Ä–æ—Å—ã.")
                return

            logger.debug(f"[{user_id}] –î–∏—Å–ø–µ—Ç—á–µ—Ä –≤—ã–∑–≤–∞–ª –æ–±—Ä–∞–±–æ—Ç—á–∏–∫: {handler.__name__}")

            all_possible_args = {
                "session": self.session, "analysis": final_analysis,
                "user_id": user_id, "original_query": query, "debug_mode": False
            }
            import inspect
            handler_signature = inspect.signature(handler)
            required_args = handler_signature.parameters.keys()
            args_to_pass = {key: value for key, value in all_possible_args.items() if key in required_args}
            
            responses = await handler(**args_to_pass)
            
            was_successful = await self._send_responses(message, responses)
            if was_successful:
                await self.dialogue_manager.update_history(user_id, final_analysis)
            
        except Exception as e:
            logger.error(f"[{user_id}] –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ GigaChatHandler.process_message: {e}", exc_info=True)
            await message.answer("–û–π, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –Ω–∞ –º–æ–µ–π —Å—Ç–æ—Ä–æ–Ω–µ.")
            
    async def process_callback(self, callback_query: types.CallbackQuery):
        """–ì–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫. –ù–∞—Ö–æ–¥–∏—Ç –Ω—É–∂–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏ –ø–µ—Ä–µ–¥–∞–µ—Ç –µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ."""
        user_id, data = str(callback_query.from_user.id), callback_query.data
        
        try:
            # --- [–ù–û–í–û–ï] –õ–û–ì–ò–ö–ê –î–ò–°–ü–ï–¢–ß–ï–†–ò–ó–ê–¶–ò–ò ---
            prefix = data.split(':', 1)[0]
            handler = self.callback_handlers.get(prefix)

            if handler:
                logger.info(f"[{user_id}] –î–∏—Å–ø–µ—Ç—á–µ—Ä –∫–Ω–æ–ø–æ–∫ –≤—ã–∑–≤–∞–ª: {handler.__name__}")
                await handler(callback_query)
            else:
                logger.warning(f"[{user_id}] –ü–æ–ª—É—á–µ–Ω –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π callback —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º '{prefix}': '{data}'")
                await callback_query.answer("–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –±–æ–ª—å—à–µ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.", show_alert=True)

        except Exception as e:
            logger.error(f"[{user_id}] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ `process_callback` –¥–ª—è data='{data}': {e}", exc_info=True)
            await callback_query.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≤—ã–±–æ—Ä–∞.")
            await callback_query.answer()

    # --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —á–∏—Å—Ç–æ—Ç—ã –∫–æ–¥–∞ ---

    async def _send_responses(self, message: types.Message, responses: list) -> bool:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""
        was_successful = True
        for resp_data in responses:
            response_type = resp_data.get("type")
            if response_type in ["clarification", "clarification_map"]:
                was_successful = False
                keyboard = self._build_keyboard(resp_data.get("buttons"))
                if response_type == "clarification_map":
                    await message.answer_photo(photo=resp_data["static_map"], caption=resp_data["content"], reply_markup=keyboard, parse_mode="Markdown")
                else:
                    await message.answer(resp_data["content"], reply_markup=keyboard, parse_mode="Markdown")
                break # –ü–æ—Å–ª–µ clarification –¥—Ä—É–≥–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ —à–ª–µ–º
            elif response_type == "text":
                await send_long_message(message, resp_data["content"], parse_mode=resp_data.get("parse_mode"))
            elif response_type == "image":
                await message.answer_photo(resp_data["content"])
            elif response_type == "map":
                kb = InlineKeyboardMarkup().add(InlineKeyboardButton("–û—Ç–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—É—é –∫–∞—Ä—Ç—É üåê", url=resp_data["interactive"]))
                await message.answer_photo(photo=resp_data["static"], caption=resp_data.get("caption", ""), reply_markup=kb, parse_mode="Markdown")
        return was_successful

    def _build_keyboard(self, buttons_data: list) -> InlineKeyboardMarkup | None:
        """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–±–æ—Ä—â–∏–∫ –∏–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä."""
        if not buttons_data: return None
        kb = InlineKeyboardMarkup()
        for row in buttons_data:
            button_row = [InlineKeyboardButton(text=btn["text"], callback_data=btn.get("callback_data"), url=btn.get("url")) for btn in row]
            kb.row(*button_row)
        return kb

    async def _reply_with_error(self, message: types.Message, log_text: str, reply_text: str = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞."):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∏ –ª–æ–≥–∏—Ä—É–µ—Ç –µ–µ."""
        logger.warning(f"[{message.chat.id}] {log_text}")
        await message.answer(reply_text)

    # --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ ---

    async def _handle_clarify_object(self, cq: types.CallbackQuery):
        await cq.message.edit_reply_markup(reply_markup=None)
        selected_object = cq.data.split(':', 1)[1]
        simulated_analysis = {"action": "describe", "primary_entity": {"name": selected_object, "type": "Biological"}}
        await self.dialogue_manager.update_history(cq.from_user.id, simulated_analysis)
        responses = await handle_get_description(self.session, simulated_analysis, cq.from_user.id, f"–£—Ç–æ—á–Ω–µ–Ω–∏–µ: {selected_object}", False)
        await self._send_responses(cq.message, responses)
        await cq.answer()

    async def _handle_pagination(self, cq: types.CallbackQuery):
        await cq.answer("–ò—â—É –¥–∞–ª—å—à–µ...")
        _, ambiguous_term, offset_str = cq.data.split(':', 2)
        simulated_analysis = {"action": "describe", "primary_entity": {"name": ambiguous_term, "type": "Biological"}, "offset": int(offset_str)}
        responses = await handle_get_description(self.session, simulated_analysis, cq.from_user.id, f"–ü–∞–≥–∏–Ω–∞—Ü–∏—è: {ambiguous_term}", False)
        # –î–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –º—ã –≤—Å–µ–≥–¥–∞ –¥–æ–ª–∂–Ω—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
        for resp_data in responses:
            if resp_data.get("type") == "clarification":
                kb = self._build_keyboard(resp_data.get("buttons"))
                await cq.message.edit_text(resp_data["content"], reply_markup=kb)
            else:
                await cq.message.edit_text(resp_data.get("content", "–ë–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."), reply_markup=None)

    async def _handle_exploration(self, cq: types.CallbackQuery):
        await cq.message.edit_reply_markup(reply_markup=None)
        _, action, geo_place = cq.data.split(':', 2)
        url = f"{API_URLS['objects_in_polygon']}?debug_mode=false"
        payload = {"name": geo_place, "buffer_radius_km": 5}
        async with self.session.post(url, json=payload) as resp:
            if not resp.ok:
                await cq.message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –ª–æ–∫–∞—Ü–∏–∏.")
                return
            api_data = await resp.json()
            objects_list = api_data.get("all_biological_names", [])

        if not objects_list:
            await cq.message.answer(f"–í —Ä–∞–π–æ–Ω–µ ¬´{geo_place}¬ª –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –æ–±–∑–æ—Ä–∞.")
            return

        if action == "full_list":
            text = f"üìã **–í—Å–µ –æ–±—ä–µ–∫—Ç—ã –≤ —Ä–∞–π–æ–Ω–µ ¬´{geo_place}¬ª**:\n\n" + "‚Ä¢ " + "\n‚Ä¢ ".join(objects_list)
            await send_long_message(cq.message, text, parse_mode="Markdown")
        
        elif action == "overview":
            await cq.message.answer("–ú–∏–Ω—É—Ç–∫—É, –≥–æ—Ç–æ–≤–ª—é —É–º–Ω—ã–π –æ–±–∑–æ—Ä...")
            analysis = await self.qa.analyze_location_objects(geo_place, objects_list)
            text = f"üåø **{geo_place}**\n\n{analysis['statistics']}\n\n"
            if analysis.get('interesting_objects'):
                text += "üéØ **–°–∞–º—ã–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–µ:**\n"
                for item in analysis['interesting_objects']:
                    text += f"‚Ä¢ **{item['name']}** - {item['reason']}\n"
            await send_long_message(cq.message, text, parse_mode="Markdown")
        await cq.answer()
    
    async def _handle_fallback(self, cq: types.CallbackQuery):
        await cq.message.edit_reply_markup(reply_markup=None)
        await cq.answer("–ò—â—É —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç...")
        
        user_id = str(cq.from_user.id)
        _, fallback_type, object_nom = cq.data.split(':', 2)
        logger.info(f"[{user_id}] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª fallback: —Ç–∏–ø='{fallback_type}', –æ–±—ä–µ–∫—Ç='{object_nom}'")

        # 1. –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –∏–∑ Redis
        context_manager = RedisContextManager()
        fallback_key = f"fallback_attributes:{user_id}"
        original_attributes = await context_manager.get_context(fallback_key)
        
        if not original_attributes:
            await self._reply_with_error(cq.message, f"–ù–µ –Ω–∞–π–¥–µ–Ω—ã –∞—Ç—Ä–∏–±—É—Ç—ã –¥–ª—è fallback –≤ Redis (key: {fallback_key})", "–û—à–∏–±–∫–∞: –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ —É—Ç–µ—Ä—è–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return

        # 2. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π, —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π `analysis`
        simplified_attributes = original_attributes.copy()
        if fallback_type == "no_season":
            simplified_attributes.pop("season", None)
        elif fallback_type == "no_habitat":
            simplified_attributes.pop("habitat", None)
        elif fallback_type == "basic":
            simplified_attributes = {}

        simplified_analysis = {
            "action": "show_image",
            "primary_entity": {"name": object_nom, "type": "Biological"},
            "attributes": simplified_attributes,
        }
        
        # 3. –û—á–∏—â–∞–µ–º Redis
        await context_manager.delete_context(fallback_key)

        # 4. –í—ã–∑—ã–≤–∞–µ–º `handle_get_picture` —Å –Ω–æ–≤—ã–º –∞–Ω–∞–ª–∏–∑–æ–º
        logger.debug(f"[{user_id}] –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤ `handle_get_picture` —Å —É–ø—Ä–æ—â–µ–Ω–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º: {simplified_analysis}")
        responses = await handle_get_picture(self.session, simplified_analysis, user_id, False)

        # 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º —É—Å–ø–µ—à–Ω—ã–π —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å –≤ –æ—Å–Ω–æ–≤–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é
        await self.dialogue_manager.update_history(user_id, simplified_analysis)

        # 6. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        await self._send_responses(cq.message, responses)